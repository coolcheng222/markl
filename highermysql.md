# 高级Mysql
[TOC]

* __逻辑架构__:

  > 连接层-服务层-引擎层-存储层

![image-20200228150218852](C:\Users\carrzhou\AppData\Roaming\Typora\typora-user-images\image-20200228150218852.png)

* __执行顺序__
>  1. from
>  2. on
>  3. A join B
>  4. where
>  5. group by
>  6. having
>  7. select
>  8. distinct
>  9. order by
>  10. limit

## 0. __SQL性能下降的原因__

  * 执行时间长

  * 等待时间长

    >1. 查询语句写的差
    >2. 索引失效
    >
    >3. 关联查询太多join
    >4. 服务器调优和各个参数设置

## 0. 七种join理论

![image-20200303113224332](C:\Users\carrzhou\AppData\Roaming\Typora\typora-user-images\image-20200303113224332.png)

![image-20200303113323843](C:\Users\carrzhou\AppData\Roaming\Typora\typora-user-images\image-20200303113323843.png)

* 全外连接用union代替

## 一.索引

* __官方定义__: 索引(Index)是帮助Mysql高效获取数据的<u>数据结构(B+树)</u>
* 其目的在于提高查找效率,类比字典
* __排好序的快速查找数据结构__
* 以索引文件形式存储在磁盘上
* 建议一张表不超过5个索引

### 1. 优劣

* 优势:

  1. 提高数据<u>检索效率</u>,降低数据库的<u>IO成本</u>

  2. 降低数据排序的成本,<u>降低了CPU的消耗</u>
* 劣势:
  1. 索引也是一张表,保存了主键和索引字段,也是要<u>占空间的</u>
  2. 虽然索引提高了存储速度,但会<u>降低更新表的速度</u>
  3. 索引知识提高效率的一个因素,<u>需要花时间研究建立最优秀的索引</u>

### 2. 分类

> **单值索引:**即一个索引只包含单个列(不推荐)
>
> __唯一索引__:索引列的值必须有唯一约束,并且允许有空值
>
> __复合索引__:即一个索引包含多个列

### 3. 语法

```sql
create [unique] index 索引名 on 表名(字段(length),...); #创建
alter 表名 add [unique] index [索引名] on (字段(length),...);#创建

drop index [索引名] on 表;#删除

show index from 表\G;#查看
```

* __主键__往往自带索引

### 4. 索引结构和检索原理

> BTree索引
>
> hash索引
>
> full-text全文索引
>
> r-Tree索引

主要以__B树索引__讨论检索原理

* 图示

  ![image-20200304201646742](C:\Users\carrzhou\AppData\Roaming\Typora\typora-user-images\image-20200304201646742.png)

### 5. 最左原则

* 复合索引下,查询索引与复合索引声明字段的__顺序__有关
* 查询时从__最左开始匹配__,一直向右
* 若中间缺乏字段,则后面的都不会用索引来搜索
* 若前面的字段是一个==范围==,后面的字段也无法使用索引

## 二 . 性能分析(Explain)

常见瓶颈:

> CPU
>
> 磁盘IO
>
> 服务器的硬件性能

### 1. 是什么

* __作用__:使用`explain`关键字可以模拟优化器执行SQL查询语句,从而知道Mysql如何处理你的SQL语句的._分析_你的查询语句或者是表结构的__性能瓶颈__.

* __语法__:

  ```sql
  explain + SQL语句;
  ```

### 2. 具体作用

> 告知操作者:
>
> 1. 表的读取顺序
> 2. 数据读取操作的操作类型
> 3. 哪些索引可以被使用
> 4. 哪些索引实际被使用
> 5. 表之间的引用
> 6. 每张表有多少行被优化器查询

### 3.结果的分析

#### 3.1 结果字段

> 1. **ID**
> 2. **select_type**
> 3. **table**(表)
> 4. **type**
> 5. **possible_keys**
> 6. **key**
> 7. **key_len**
> 8. **ref**
> 9. **rows**
> 10. **Extra**

#### 3.2 ID

* __定义__:select查询的序列号,包含一组数字,表示_查询中执行select<u>子句</u>或<u>操作表的顺序</u>_.

* 三种情况:

  > 1. __ID相同__:执行顺序由上至下
  > 2. __ID不同__: 如果是子查询,ID的序号会递增,值<u>越大越优先</u>被执行
  > 3. __ID相同不同,同时存在__:数字大的执行,相同的从上到下执行

* __衍生虚表(derived)__
  * 从某ID步骤衍生出来的虚的表(from子查询)称为<derived [id\]\>,放在`table`栏内
  * 后面细讲

#### 3.3 Select_type

* 常见6个值

| id   | select_type  | 意义                                            |
| ---- | ------------ | ----------------------------------------------- |
| 1    | simple       | 简单查询,不含子查询或union                      |
| 2    | primary      | 若包含任何复杂子部分,最外层的部分               |
| 3    | subquery     | select 或 where子查询                           |
| 4    | derived      | 在from的子查询,结果放在临时表里                 |
| 5    | union        | 若**第二个select**出现在union之后,则标记为union |
| 6    | union result | union**合并的结果**                             |

#### 3.4 type(*)

* __意义__:访问类型排列

* __八个常用值__

  | 值(从好到差) | 好->差                                                       |
  | ------------ | ------------------------------------------------------------ |
  | system       | system表只有一行记录(相当于系统表)(const的特例)              |
  | const        | 通过索引一次就找到,一般对主键/unique使用where会出现,返回的往往是一个常量 |
  | eq_ref       | 唯一性索引扫描,对于每个索引建,表只有一条记录与之匹配         |
  | ref          | 非唯一性索引扫描,返回匹配某个单独值的所有行                  |
  | range        | 只检索给定范围的行,用索引选择行,key显示使用哪个索引          |
  | index        | 只遍历索引树的查询                                           |
  | all          | 全表扫描,从硬盘读取                                          |
  | NULL         |                                                              |

  * 一般至少达到`range`,最好`ref`

#### 3.5 possible_keys

* __内容__:显示可能应用在这张表中的索引,一个或多个.
* 若查询涉及到的字段存在索引则被列出,但<u>不一定被查询实际使用</u>

#### 3.6 key

* __内容__:<u>实际使用</u>的索引,若为NULL则没有用索引或索引失效
* 查询中若是用了<u>覆盖索引</u>,则该索引仅出现在key列表中(不出现在possible中)

> ==覆盖索引==: select后面的字段和某个符合索引刚好一致(完全匹配),以至于只需要扫描索引树

#### 3.7 key_len

* 表示索引中使用的__字节数__,显示__最大使用长度__而非实际长度,根据表定义而得.

* 越短越好,但越短越不精确.所以__在不损失精度的前提下越短越好__

#### 3.8 ref

* 显示索引的哪一列被使用了,如果可能最好是个常数.(主要看下一行理解,这行不行)
* 换言之,说明当前表索引<u>匹配的目标</u>是常量还是别的表中的某个列
* 突出的部分是__表之间的引用__

#### 3.9 rows

* 根据表统计信息及索引选用的情况,大致估算出找到所需记录<u>所需读取的行数</u>

* eq_ref(唯一性索引)下,rows为1

#### 3.10 extra

* 包含不适合在其他列显示__但十分重要的信息__

* 内容:

> 1. __Using FileSort__: 表示mysql会对数据库使用一个外部的索引排序,而不是按照表内的索引顺序读取.
>
>    * mysql中无法利用索引完成的排序称为__文件内排序__
>    * ==出现这个很危险==
>    * 如果一复合索引只用到一部分,则排序很可能出现这个问题
>
> 2. __Using temporary__: 使用了<u>临时表</u>保存中间结果,mysql在对查询结果排序时使用临时表,常见于 `order by`和`group by`
>
>    * group by最好跟着索引的顺序数量走
>
> 3. __Using index__: 表示相应select操作中使用了<u>覆盖索引</u>,避免了访问表的数据行
>
>    * 很棒
>
> 4. using where:使用了where过滤
>
> 5. using join buffer:使用了连接缓存
>
> 6. impossible where:where的子句总是不成立
>
> 7. select tables optimized away:
>
>    在没有group by做的索引优化操作
>
> 8. distinct:优化distinct,出现第一个就停止

## 三.索引的建立和优化

### 1. 索引分析

>  1. 索引出现范围会使后面索引失效
>  2. 在两表连接下,在左右表的索引会有区别,比如左连接保证左表全有,所以宜在右表加索引
>  3. 尽量减少join的nestedloop的循环总次数,__永远用小结果集驱动大的结果集__
>  4. 优先优化nestedloop的内存循环
>  5. 保证join被驱动表上的join条件已经被索引
>  6. 当极端清苦下,不要吝惜join buffer

### 2. 索引优化

#### 2.1索引失效

* 重要十条

> 1. 全值匹配我最爱
> 2. __最佳左前缀法则__
> 3. 不在索引列上做任何操作(计算,函数,类型转化),不然会导致索引失效
> 4. 存储引擎不能使用索引中范围条件右边的列
> 5. 尽量使用覆盖索引,减少select *
> 6. 使用不等于时会导致索引失效
> 7. is (not)null也无法使用索引
> 8. like 以通配符<u>开头</u>会导致索引失效
> 9. 字符串不加单引号索引失效
> 10. 用or连接时会索引失效

##### 2.1.1 最佳左前缀法则

* 如果索引了多列,要遵守__最佳左前缀法则__.即查询从索引最左前列开始,__并不跳过索引中的列__

* 全值匹配:带头大哥不能走,中间兄弟不能断

* 在范围下的字段会被用到,但是范围右边的字段索引失效 

##### 2.1.2 like'%%'时索引不被使用的方法

* 使用覆盖索引,需要like的字段放置在索引里
* 右百分不是范围查询
* 左百分是模糊的查询,本身也失效

##### 2.1.3 varchar单引号

* 本条指数字字符串的自动转换,若是用了自动转换.索引失效.

## 四. 查询截取分析

分析步骤:

> 1. 观察,至少跑一天,看看生产慢的sql情况
> 2. 开启慢查询日志,设置阈值,抓取慢sql
> 3. explain+sql分析
> 4. show profile分析
> 5. 运维经理/DBA进行服务器参数调优

### 1. 查询优化

* __永远小表驱动大表__,故有`in/exists`

#### 1.1 in/exists

* 例题&解析:

  ```sql
  select * from A where id in (select id from B);
  #这是一个用B驱动A的案例,使用了in
  #适合B表小的时候
  
  select * from A where exists (select 1 from B where B.id=A.id);
  #这是用A驱动B的案例,使用了exists
  #可以看做:将主查询的数据放进子查询做验证
  #适合A表小的时候
  ```

#### 1.2 order by关键字优化

尽量使用index方式排序,避免使用filesort.

* 在这样的情况下会`using index`:
  * order by语句使用索引最左前列
  * 使用where子句(常量)与order by子句条件列组合满足索引最左前列

* 在一个索引__同时__产生升序和降序时,不能用索引排序降序的字段.
  
* 故曰:==同升同降==
  
* `FILESORT`算法

  > __双路排序__:在mysql4.1前使用双路排序,也即__两次扫描硬盘__最终得到数据.第一遍排序(在buffer中),第二遍读取值.
  >
  > __单路排序__:在buffer中排序并扫描排序后的列表输出,避免了第二次读取数据.
  >
  >
  > 单路总体强于双路.但是一次如果数据总大小超过sort_buffer容量,则还要取多次.

* `filesort`的优化策略
  * 增大`sort_buffer_size`参数
  * 增大`max_length_for_sort_date`参数

#### 1.3 group by关键字优化

group by的实质是先排序后分组,故__与order by基本相近__.甚至filesort和sort_buffer策略都一致.

* where大于having,所以能在where写的最好不要用having

### 2. 慢查询日志

* __是什么__:mysql__慢查询日志__是mysql提供的一种日志记录,用来记录在mysql中响应时间超过阈值的语句.

  具体指运行时间__超过(大于)__`long_quert_time`的sql,会记录到慢查询日志中.

* 默认是__关闭的__,因为慢查询日志会带来性能影响,一般调优的时候才开启.

* __咋开启__:

  * 查看是否开启:

    ```sql
    show variables like '%slow_query_log%';
    ```

  * 开启:

    ```sql
    set global slow_query_log=1;
    #只对本次生效
    #想永久去my.cnf文件改(加参数)
    
    show variables like '%long_query_time%';
    #阈值,默认十秒,
    ```

  * 重新设置阈值后需要重启才能生效.

* 相关变量

  | 变量                 | 含义               |
  | -------------------- | ------------------ |
  | slow_query_log       | 慢查询日志是否开启 |
  | slow_query_log_file  | 慢查询日志文件     |
  | long_query_time      | 慢查询阈值         |
  | slow_queries(status) | 慢查询sql条数      |
  
* __日志分析工具mysqldumpslow__:

  在mysql外使用(linux终端)

  ```sql
  mysqldumpslow --help;#查看帮助
  ```

  * mysqldumpslow 选项(们) 日志文件(们)

  * 选项:

    `-s 参数 `按何种方式排序

    * `al`平均锁时间
    * `ar`平均返回记录数
    * `at`平均查询时间
    * `c`访问次数

    * `l`锁定时间

    * `r`返回记录

    * `t`查询时间

    `-t n`返回前面n条数据

    `-g 正则表达式`搭配大小写不敏感的正则表达式使用

    

### 3. 批量数据脚本

> 1. 建表
> 2. 设置二进制日志参数`log_bin_trust_function_creation`
> 3. 创建函数,保证每条数据都不同
> 4. 创建过程,利用随机数函数产生数据并插入

### 4. show profiles分析

* __是什么__:是mysql提供可以用来分析当前会话中语句执行的资源消耗情况,可以用于SQL调优的测量.
* 默认情况下,参数处于关闭状态,并保存最近15次运行的结果
* show variables like 'profiling'
* __咋玩__:

```sql
  show profiles; 
  #查看最近n条sql运行时间情况
  
  show profiles cpu,block io for query <语句id>;
  #查看某个语句的cpu,block io使用情况
```
* __相关变量__:

| 变量                   | 作用                     |
| ---------------------- | ------------------------ |
| profiling              | profile是否开启          |
| profiling_history_size | profile记录最后多少条sql |

* show profiles__参数列表__:

  | 参数             | 意义                                                        |
  | ---------------- | ----------------------------------------------------------- |
  | all              | 所有开销信息                                                |
  | block io         | 显示块io开销                                                |
  | context switches | 上下文切换相关开销                                          |
  | cpu              | 一切cpu相关开销信息                                         |
  | ipc              | 显示发送和接收相关开销信息                                  |
  | memory           | 显示内存相关开销信息                                        |
  | page faults      | 显示页面错误相关开销信息                                    |
  | source           | 显示和source_function,source_file,source_line相关的开销信息 |
  | swaps            | 显示交换次数相关的开销信息                                  |

* profile__结果分析__:

  坏结果的标志:

  > * __converting HEAP to MyISAM__: 查询结果太大,内存不够用了,只能用磁盘了.
  > * __create tmp table__ :创建临时表,用完再删除
  > * __copying to tmp table on disk__:把内存中的临时表复制到磁盘.
  > * __locked__:锁了

-----

### 5. 全局查询日志

只允许在测试环境使用,__'永远不要在生产环境开启这个功能__.

* 相关变量

  | 变量              | 作用             |
  | ----------------- | ---------------- |
  | general_log       | 全局日志是否开启 |
  | general_log_file  | 全局日志的文件   |
  | mysql.general_log | 全局日志的表     |

---

## 五.mysql锁机制

__锁__是计算机协调多个进程或线程并发访问某一资源的机制.

* __分类__:

  > * 从操作类型分:  
  >
  >   **读锁(共享锁):**针对统一数据,多个读操作同时进行不相互影响(不能写)
  >
  >   **写锁(排它锁)**:当前写操作没有完成前,会阻断其他写锁和读锁
  >
  > * 从操作粒度分:
  >
  >   **表锁**:偏向读的myisam引擎
  >
  >   **页锁**
  >   
  >   **行锁**

### 1. 表锁(myisam)

myisam是偏__读__引擎

* __语法__:

  ```sql
  lock table 表名1 read(write),表名2 ,......;
  #当场锁表
  
  show open tables;
  #观察哪些表被锁过
  
  unlock tables;#解开所有锁
  ```

#### 1.1 读锁

* __结果__:

  |          | 加锁人 | 其他人       |
  | -------- | ------ | ------------ |
  | 查锁的表 | 可以   | 可以         |
  | 写锁的表 | 不可以 | 阻塞到锁解除 |
  | 查别的表 | 不可以 | 可以         |
  | 写别的表 | 不可以 | 可以         |

#### 1.2 写锁

|          | 加锁人 | 其他人 |
| -------- | ------ | ------ |
| 查锁的表 | 可以   | 阻塞   |
| 写锁的表 | 可以   | 阻塞   |
| 查别的表 | 不可以 | 可以   |
| 写别的表 | 不可以 | 可以   |

#### 1.3 总结

简而言之,就是读锁会阻塞写,不会阻塞读.而写锁会把读和写都阻塞.

#### 1.4 表锁分析

```sql
show open tables;#上述过了

show status like 'tables';#以下是结果分析
```

* `Table_locks_immediate`:产生表级锁定的次数,表示可以立即获取锁的查询次数	

* `Table_locks_waited`:出现表级锁定争用而发生等待的次数.越高争用越严重

-----

### 2. 行锁

行锁偏向InnoDB存储引擎,开销大,加锁慢,会出现死锁,粒度最小,发生锁冲突的概率最大,并发度最高.行锁的实现__依赖于索引__.

InnoDB支持事务,采用行锁.

结合__隔离级别__食用更佳.

> 索引失效会导致行锁变成表锁

#### 2.1 间隙锁的危害

* __间隙锁__:当用范围条件而不是相等条件de检索数据请求锁时,innodb会给符合条件的已有数据索引项加锁.对于键值在条件范围内但并不存在的记录称为__间隙(GAP)__.

  innodb会对间隙和已有记录加锁,称为__间隙锁机制(next-key锁)__

#### 2.2 如何锁定一行

* 有样学样:

  ```sql
  begin;
  select * from test_innodb_lock where a=8 for update; #for update锁好
  commit;
  ```

  

#### 2.3 行锁总结

```sql
show status like 'innodb_row_lock';
```

寻找`InnoDB_row_lock_waits`

`InnoDB_row_lock_current_waits`

`Innodb_row_lock_time_avg`

作为指标

## 六. 主从复制

* __基本原理__:

  slave从master读取binlog来进行数据同步

  > 1. master将改变记录记录到二进制日志中.称为二进制日志事件,binary log events
  > 2. slave将master的bin_log_events拷贝到它的中继日志(relay log)
  > 3. slave重做中继日志中的时间,将改变应用到自己的数据库中

* mysql的赋值是__异步的,串行的__

* __规则__: 
  * slave只能有一个master
  * slave只能有一个唯一的服务器ID
  * master可以有多个slave

* __最大问题__:延时