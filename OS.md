# 操作系统

> [TOC]

## 一. 绪论

### 1. 操作系统的地位

本质是__系统软件__

* <u>系统资源的管理者</u>
  * 处理机(CPU)管理
  * 存储器(内存)管理
  * 文件管理
  * 设备管理
  * 以安全高效为目标
* <u>用户与计算机硬件之间的接口</u>
  * 命令接口: 允许用户直接使用
    * 联机(交互式)命令接口
    * 脱机(批处理)命令接口
  * 程序接口: 允许用户通过程序间接使用
    * 由一组__系统调用/程序接口/广义指令__组成(同一个意思)
  * GUI
  * 以**方便用户**使用为目标
* <u>最接近硬件的层次</u>
  * 没有软件支持的计算机称为__裸机__,覆盖了软件的机器称为__扩充机器/虚拟机__

### 2. 操作系统四大特征

> ==**并发**==
>
> ==**共享**==
>
> ==**虚拟**==
>
> ==**异步**==

#### 2.1 并发

* 定义:

  **并发**指两个或多个时间在$\color {blue}同一时间间隔发生$. <u>宏观上同时发生,在微观上交替发生</u>

  * 易混淆: __并行__指连个或多个事件在$\color {blue}同一时刻同时发生$

  **操作系统的并发性** 指计算机系统中同时存在着多个运行着的程序

  * 单核CPU同一时刻只能执行一个程序,因此操作系统会负责协调多个程序交替执行
  * 操作系统和"多道程序技术"是伴随出现的,所以操作系统和程序并发一起诞生

#### 2.2 共享

* 定义:

  __共享__即资源共享,指系统中的资源可供内存中多个并发执行的进程共同使用

* 分类:两种资源共享的方式
  * 互斥共享方式(一个时间段只允许一个进程访问该资源)
  * 同时共享方式(一个时间段内进程可以"同时"访问该资源)

#### 并发和共享的关系

如果失去并发性,共享性也失去了存在的异议

如果没有共享性,就无法并发

**互为存在条件**

#### 2.3 虚拟

__虚拟__是指把一个物理上的实体变成若干个逻辑上的对应物.前者是实际存在的,后者是用户感受到的.

* ""空分复用技术"(空间 虚拟存储器)
* "时分复用技术"(时间 虚拟处理器)

没有并发性,谈不上虚拟性

#### 2.4 异步

__异步__是指,多道程序环境下,允许多个程序并发执行,但由于资源有限,进程的执行不是一贯到底的,而是走走停停(阻塞),以不可预知的速度向前推进,这就是进程的异步性.

没有并发性也没有异步性

--------

### 3. OS的发展和分类

1. ==手工发展阶段==
   * 纸带打孔
   * CPU快,IO慢,人类处理慢
   * 缺点总结: 用户独占主机,人机速度矛盾导致资源利用率低
2. ==批处理阶段--单道批处理系统==
   * 引入__脱机输入/输出技术__(读到磁带里,输出到磁带),并由__监督程序(OS雏形)__负责控制作业的输入输出
   * 优点: 缓解了一定程度的人机速度矛盾,资源利用率有所提升
   * 缺点: 内存中**仅有一道程序运行,只有该程序运行结束才能调入**下一道,CPU有大量时间是在**等待IO完成**,资源利用率也不高
3. ==批处理阶段--多道批处理处理技术==
   * 每次往内存中输入多道程序,引入了__中断技术__
   * __操作系统正式诞生__,负责管理这些程序运行,各个程序并发执行
   * 优点: 多道程序**并发执行**,**共享**计算机资源,资源利用率大大提升.CPU和其他资源保持忙碌状态,系统吞吐量增大
   * 缺点: 用户响应时间长,没有人机交互功能
   * ![image-20200525144428484](C:\Users\carrzhou\AppData\Roaming\Typora\typora-user-images\image-20200525144428484.png)
   * ![image-20200525144452242](C:\Users\carrzhou\AppData\Roaming\Typora\typora-user-images\image-20200525144452242.png)

4. ==分时操作系统==
   * 计算机以__时间片__为单位轮流为各个用户/作业服务,各个用户可以通过终端与计算机交互
   * 优点: 用户请求可以被即时响应,解决了人机交互问题,允许多个用户同时使用一台计算机,并且用户对计算机的操作相互独立,感受不到别人存在
   * 缺点: **不能优先处理一些紧急任务,**每个用户都是公平的
5. ==实时操作系统==
   * 在实时操作系统的控制下,计算机系统接受到外部信号后及时进行处理,并且要在**严格时限内处理完事件.**(硬实时要求必须,软实时接收偶尔违反)
   * 优点: 能够优先相应一些紧急任务,某些紧急任务不需要时间片排队
   * 特点: **及时性,可靠性**

6. 其他

   网络操作系统

   分布式操作系统

   个人计算机操作系统

### 4. OS运行机制和体系结构

#### 4.1 运行机制

* __两种指令__:
  * <u>特权指令</u>
  * <u>非特权指令</u>
* __两种处理器状态__:
  * <u>用户态**(目态)**</u> : 只能执行非特权指令
  * <u>核心态**(管态)**</u> :都能执行
  * 两种状态用__程序状态字寄存器(PSW)__中的某个标志位标识(0用户态,1管态)
* __两种程序__:
  * <u>内核程序:</u> 是系统的管理者,运行在核心态
  * <u>应用程序</u> : 运行在用户态

#### 4.2 OS内核(kernel)

内核掌管`时钟管理`,`中断处理`,`原语(最接近硬件,有原子性)`,`进程管理,存储器管理,设备管理等功能`

__内核__是计算机配置上的__底层软件__,是操作系统最基本,最核心的部分.

实现操作系统功能的的程序就是__内核程序__

![image-20200525150333985](C:\Users\carrzhou\AppData\Roaming\Typora\typora-user-images\image-20200525150333985.png)

#### 4.3 体系结构

OS的体系结构分为`大内核`和`微内核`

* 如果操作系统内核只包含最基本的功能,则为__微内核__
  * 优点: 内核功能少,结构清晰,易于维护
  * 缺点: 需要频繁地在核心态和用户态之间切换,性能低
* 将操作系统主要模块都作为系统内核,则为__大内核__
  * 优点: 高性能
  * 缺点: 内核代码庞大.结构混乱,难以维护

### 5. 中断和异常

早期个程序只能串行执行,效率低下. 

人们发明了操作系统,引入中断机制,实现了多道程序并发执行.

* __本质__: 发生中断意味着**需要操作系统介入,**开展管理工作
  * CPU在收到中断信号会转换为**核心态**
  * ,**由操作系统内核对中断处理**
  * 对不同的中断信号,会进行不同处理
* 用户态与核心态
  * <u>用户态到核心态的切换</u>是通过中断来实现的,<u>并且中断是唯一的途径</u>	
  * 而<u>核心态到用户态</u>通过特权指令,改变程序状态字

#### 5.1 分类

* ==内中断(异常,例外,陷入)==
  * 来源: CPU**内部,**与**当前执行的指令有关**
    * ==自愿中断==--仿管(trap,陷入)指令中断
    * ==强迫中断==(硬件故障(缺页)/软件中断(除以0))
* ==外中断(狭义中断)==
  * 来源: CPU__外部__,当前执行的指令__无关__
    * ==外设请求==(例如IO操作完成)
    * ==人工干预==

* __另一种内中断分类__
  * 陷阱,陷入(trap): 有意而为之的,如系统调用
  * 故障(fault) :由错误条件引起的,可能被故障处理程序修复
  * 终止(abort) :不可修复的致命错误,不再将控制权返回

### 6. 系统调用

前面我盟说过,程序接口由__一组系统调用__组成

应用程序通过**系统调用**请求操作系统的服务.凡是与**资源有关**的操作,都必须通过系统调用的方式向操作系统提出服务请求,由操作系统代为完成,这样可以**保证系统的稳定性和安全性**,防止用户非法操作

需要特权指令,运行在__核心态__

可以理解为操作系统提供的接口.

* 按功能分类:
  * 设备管理 : 完成设备的 请求 释放 启动等
  * 文件管理 : 完成文件的 读写创建删除 等
  * 进程控制 : 完成进程的 创建撤销阻塞唤醒
  * 进程通信 : 完成进程的 消息传递 信号传递
  * 内存管理 : 完成内存的 分配/回收功能

* 调用:
  * 前期处理相关指令
  * trap指令/陷入指令(内中断)
  * 后续处理指令,操作系统处理 系统调用 相关代码(核心态)
  * 注意: __陷入指令是唯一只能在用户态而不能在核心态执行的指令__

## 二. 进程

### 1. 进程

* 定义:
  * __程序__: 一个指令序列
  * 为了方便管理.完成个程序并发执行,引入了__进程,进程实体__的概念
    * <u>PCB(进程控制块),程序段,数据段构</u>成了__进程实体/进程映像__,简称进程
    * ==PCB是进程存在的唯一标志==
  * 进程是进程实体(静态)的__运行过程__,是__动态的__,是资源分配和调度的一个独立单位

* __组成__

  * 程序段: 存储程序代码
  * 数据段: 产生的数据
  * PCB: 操作系统通过PCB管理进程,存储操作系统对其管理的各种信息
    * **进程描述信息:** 
      * 进程标识符PID
      * 用户标识符UID
    * **进程控制和管理信息**
      * 进程当前状态
      * 进程优先级
    * **资源分配清单**
      * 程序段指针
      * 数据段指针
      * 键盘
      * 鼠标
    * **处理机相关信息 --寄存器的值**

* __组织__:

  PCB成百上千,组织讨论的是多个进程之间的组织方式问题.

  * **链接方式**
    * 按照进程状态把PCB分为多个队列,操作系统持有指向各个队列的指针
      * 
  * **索引方式**
    * 根据进程状态不同,建立几张索引表,操作系统拥有指向索引表的指针

整体来说,就是有`执行指针,就绪队列指针,阻塞队列指针`

* __特征__
  * **动态性**: 最基本特征,动态的产生和消亡
  * **并发性**: 各进程并发自行
  * **独立性**: 进程是__能独立运行,独立获取资源,调度的基本单位__
  * **异步性** : 各自独立,不可预知,需要进程同步机制
  * **结构性**: PCB+程序段+数据段

### 2. 进程状态转换

#### 2.1 三种基本状态

* __运行态(Running)__: 占有CPU,单核下时刻最多有一个运行态进程
* __就绪态(Ready)__: 拥有除了处理机外的所有资源,就等CPU
* __阻塞态(waiting/blocked)__:

#### 2.2 另外两种

* __创建态(New)__: 分配资源,初始化PCB
* __终止态(Terminated)__: 反上


#### 2.3 转换

![image-20200527150307525](C:\Users\carrzhou\AppData\Roaming\Typora\typora-user-images\image-20200527150307525.png)

### 3. 进程控制

进程控制的主要功能是对系统中所有进程实施有效的管理,它具有创建新进程,撤销已有进程,实现进程状态转换等功能.

#### 3.1 如何实现进程控制?

使用==原语==实现进程控制,其__特点__是<u>原子性:执行期间不允许中断</u>,也叫原子操作

原语采用__关中断指令__和__开中断指令__实现,是核心态的特权指令

关中断下收到外部中断信号不会处理,开中断会处理

所做的事无非是`更新PCB信息(状态标志,运行环境)`,`将PCB放入合适队列`,`分配回收资源`

* __创建进程__:
  * 由`创建原语`: 
  * 需要初始化PCB,分配系统资源
* 创建态到就绪态:
  * 修改PCB内容和相应队列
* 就绪态到运行态:
  * 恢复进程运行环境,修改PCB内容和相应队列
* 运行态到阻塞态:
  * 阻塞原语
  * 保存进程运行环境,修改PCB内容和相应队列
* 阻塞态到就绪态:
  * 唤醒原语(和阻塞原语曾对出现)
  * 修改PCB内容和相应队列,分配资源
* 运行态到终止态:
  * 由`撤销原语`:找到PCB,剥夺CPU,中止子进程,收资源,删PCB
  * 回收资源,撤销PCB

还有进程切换原语

#### 3.2 引起进程创建/结束的事件

* 用户登录
* 作业调度
* 提供服务
* 应用请求



* 正常结束
* 异常结束
* 外界干预

### 4. 进程通信

进程之间的信息交换叫进程通信.

每个进程拥有内存地址空间,相对独立,进程之间不能互相直接访问.

#### 4.1 三大方式

* **共享存储**:
  * 基于数据结构的共享
  * 基于存储区的共享
* **消息传递**
  * 直接通信方式
  * 间接通信方式
* **管道通信**

#### 4.2 共享存储

进程之间分配一个共享空间,但是每个时刻只有一个进程能访问(称为__互斥性__),操作系统会提供同步互斥工具

* 基于数据结构的共享:

  * 只能村固定的数据结构

  * 速度慢,限制多,是低级通信方式
* 基于存储区共享
  * 在内存划一块共享存储区
  * 是高级方式

#### 4.3 管道通信

__管道__是指用于连接读写进程的共享文件,又名pipe.就是内存中开辟的固定大小缓冲区

* 管道只能实现__单双工通信__,某个时间段只能单向传输,想双向同时必须两个管道.
* 各进程__互斥__的访问管道
* 数据以__字符流__写入管道,写满时写进程的write()阻塞,这时才能开始取数据.取完(管道为空)时read()阻塞,才能写
* 读出管道的数据就被抛弃了,所以读进程就只有一个

#### 4.4 消息传递

进程间数据以__格式化消息__为单位,通过__发送消息/接收消息原语__进行数据交换

* 格式化消息
  * 消息头: 包括进程ID,接收进程ID,消息类型,长度等信息.
  * 消息体
* 直接通信方式:
  * 消息直接挂在接收进程消息的缓冲队列上
* 间接通信方式:(信箱通信方式)
  * 先发送到中间实体(信箱)

## 三. 线程

一个进程多个功能,传统进程内部串行,所以需要多线程<u>增加并发度</u>

__线程__被引入后,成为了<u>程序执行流的最小单位</u>,<u>CPU最小单元</u>

而进程成为了<u>除了CPU以外的系统资源的分配单元</u>

### 1. 变化

* 资源分配,调度
* 并发性
* 系统开销
  * 切换线程,开销小
  * 进程切换开销极大

### 2. 属性

* 线程是处理机调度的基本单位
* 多CPU计算机中,各个线程可占用不同CPU
* 每个线程有一个ID,线程控制块(TCB)
* 线程也有就绪,阻塞,运行三个状态
* 几乎不拥有系统资源
* 同一进程不同线程共享进程资源
* 同一进程的线程通信无需系统干预
* 同一进程中的线程切换不会引起进程切换,不同的就会
* 切换同一进程的线程开销小

### 3. 实现方式

* **用户级线程(ULT)**
  * 通过线程库来实现. 所有**线程管理工作由应用程序负责**(包括线程切换)
  * 在**用户态**下即可完成,对操作系统看不到线程存在
* __内核级线程(KLT)__
  * **由操作系统内核完成线程管理**,核心态
  * 从操作系统角度能看到的线程

如果两者同时支持,可以吧n个用户级线程映射到m个内核级线程上.

因为操作系统只能看到内核级线程,所以__内核级线程才是处理机分配的单位__.

比如用户3个线程映射到内核2个线程,那最多有2个核执行线程,只有2个线程并行

* 多线程问题:
  * 因为用户级和内核级的映射问题,产生了多线程模型问题
  * __多对一__: 多个用户级映射到一个内核级时
    * 线程切换只需要在用户态
    * 并发性不高,阻塞时进程被阻塞
  * __一对一__:纯粹的内核级线程
    * 并发能力强,多核并行
    * 管理的成本高
  * __多对多__:n个映射到m
    * 并发还行,成本还行

## 四. 处理机调度

当有一堆任务要处理,但由于资源有限,不能同时处理,这就需要确定**某种规则**来**决定**处理这些任务的**顺序**,这就是调度的研究问题

简单地说,从就绪队列中按照**一定算法选择一个进程**并将处理机分配给它运行

### 1. 三个层次

* __高级调度(作业调度)__: 按一定原则从外存处于后备队列的作业中挑选一个作业,分配内存等资源并建立PCB(进程),使他们获得竞争 处理机的权利
  * 是__外存和内存__之间的调度,每个作业只调入一次,调出一次,作业调入设置会建立相应的PCB,调出是撤销PCB.
  * 高级调度指的是调入问题.
  * 无-->创建态-->就绪态
* __中级调度(内存调度)__:引用虚拟存储技术之后,可将暂时不能运行的进程调至外存等待,当他具备了运行条件且内存有空闲时再重新调回内存
  * 目的是**提高内存利用率**和**系统吞吐量**
  * 暂停的进程状态为__挂起__,而PCB却__常驻内存__,放在__挂起队列中__
  * 中级调度处理的是哪个处于挂起状态的进程进入内存
  * 频率比高级调度高
* 补充:七状态模型
  * 就绪挂起: 就绪态需腾出内存挂起
  * 阻塞挂起: 阻塞态腾出内存,有事时可以变成就绪挂起
  * 运行态和创建态都能直接到就绪挂起
* __低级调度(进程调度)__: 用算法给进程分配处理机
  * 操作系统中最基本的调度
  * 频率很高

### 2. 进程调度

#### 2.1 进程调度时机

* 当前运行的进程**主动放弃**处理机(有的系统只允许这个)
  * 正常终止,异常终止,请求阻塞
* 当前运行的进程**被动放弃**处理机
  * 时间片用完
  * 有更紧急的事处理(如IO中断)
  * 有更高优先级的进程进入优先队列

* 不能进行进程调度的情况:
  * 处理中断的过程中
  * <u>操作系统内核程序临界区</u>中
    * __临界资源__: 一个时间段内只允许一个进程使用的资源,各进程需要互斥的访问临界资源
    * __临界区__:访问临界资源的那一段代码
    * __内核程序临界区__: 访问某种内核程序,比如进程就绪队列
    * 如果内核临界区的临界资源不尽快释放可能影响到其他内核管理工作,所以不能进程调度
  * 原语操作不可中断

#### 2.2 进程调度方式

* __非剥夺(非抢占)方式__: 只允许进程主动放弃处理机,直到中止或阻塞
* __剥夺(抢占)调度方式__: 当一个进程在处理机执行时,如果有一个更重要的进程使用,则立即暂停当前进程,分配给紧急进程

#### 2.3 进程切换与过程

* __狭义的进程调度__: 指从就绪队列中选中一个要运行的进程
  * 可以是刚被暂停的,也可以是另一个进程,后者需要__进程切换__
* __广义的继承调度__: 包含了狭义进程+进程切换

* 进程切换的过程主要完成了:
  * 对原来运行的进程的各种数据的保存
  * 对新进程数据的恢复

频繁的个切换会使系统效率变低

### 3. 调度算法的评价指标

* __CPU利用率__: 指CPU忙碌的时间占总时间的比例
  $$
  利用率=\frac {忙碌时间}{总时间}
  $$
  
* __系统吞吐量__: 单位时间内完成作业的数量
  $$
  吞吐量(道/秒)=\frac {总共完成多少道作业}{总共多少时间}
  $$

* __周转时间__: 指作业被提交给系统开始.到作业完成的时间间隔

  * 分为:高级调度时间,低级调度时间,CPU执行时间,等待IO时间

  * __平均周转时间__: 各作业周转之和/作业数

  * __带权作业周转时间__:(必然大于1)(越接近1越好)
    $$
    带权作业周转时间=\frac{作业周转时间}{作业实际运行时间}=\frac{作业完成时间-作业提交时间}{作业实际运行时间}
    $$

  * __平均带权周转时间__: 上面除以作业数

* __等待时间__:指进程.作业处理等待处理机状态时间之和,越小越好

  * 对于__进程__来说,等待时间是进程建立后等待被服务的时间之和(**IO不计入等待时间**)
  * 对于__作业:__ 不仅考虑建立进程后的等待时间,也要加上作业在外存后备队列的准备时间
  * 调度算法只会影响等待时间,也有平均等待时间

* __响应时间__:用户提出请求到首次产生相应的时间

### 4. 调度算法

__饥饿__: 一个作业/进程长时间不被服务

#### 4.1 先来先服务(FCFS)

* 算法思想: 从公平角度考虑
* 算法规则: 按作业/进程到达的先后顺序进行服务
* 用于__作业调度时__,考虑哪个作业先到达后备队列,用于__进程调度__时,考虑哪个进程先到就绪队列
* 是否抢占? 非抢占
* 优点:
  * 公平,算法实现简单
* 缺点:
  * 对于排在长作业后面的短作业来说需要等很长时间.带权周转大:
  * 对长作业有利,对短作业没利
* 是否会导致饥饿: __不会__

#### 4.2 短作业优先(SJF)

* 算法思想: 追求最少的平均等待时间.最少的平均周转时间,最少的平均带权周转时间
* 算法规则: 最短的作业.进程优先得到服务(前提是已经到达)
* 用于作业也用于进程(用于进程叫短进程算法SPF)
* 抢占? __非抢占__,但是有抢占版本__最短剩余时间优先算法(SRTN)__
  * 如果题中不提,那是非抢占式的
  * 在所有进程同时可运行(或者几乎同时到达)时,采用SJF调度算法的平均等待时间,平均周转时间最少
  * 如果没有条件,则称SRTN是平均周转时间,平均等待时间最少

* 优点: 最短的平均等待时间,平均周转时间
* 缺点: 不公平,短作业有利,长作业不利,可能昌盛__长作业饥饿__.而且运行时间是用户提供的.不一定真实
* 饥饿: 会的,甚至"饿死"

#### 4.3 高响应比优先算法(HRRN)

* 算法思想: 综合考虑作业/进程的等待时间和要求服务的事件

* 算法规则:  在每次调度时先计算各个作业/进程的__响应比__,选择__响应比最高__的作业/进程服务
  $$
  响应比=\frac {等待时间+要求服务时间}{要求服务时间时}
  $$

* __非抢占__,需要等当前作业/进程放弃处理机

* 综合了上面两个算法的优点

* 交互性很糟糕

* 不饥饿

#### 4.4 时间片轮转调度算法(RR)

* 思想: 公平的,轮流的为各个进城服务,让每个进程在一定时间间隔内都可以得到相应
* 规则: 按照各个进程到达就绪队列的顺序,轮流的让各个进程执行一个时间片(如100ms),若进程未在一个时间片内执行完,则剥夺处理机,让进程重新放到就绪队列队尾排队
* __只用于进程调度__
* __抢占式__,由始终装置发出的__时钟中断__来通知CPU时间片已到
* 计算时,更注重响应时间
* 优点:公平,响应快,适用于分时操作系统
* 缺点: 高频率进程切换开销大,不区分进程紧急程度
* 如果__时间片__太大,使得每个进程可以在一个时间片内完成,则时间片轮转调度算法会退化为先来先服务调度算法,增大响应时间,不好;如果__时间片太小__,频繁的切换进程会花大量时间,也不好

* 不会饥饿

#### 4.5 优先级调度算法

* 思想: 随着计算机发展,特别是实时操作系统出现,越来越多的应用场景需要根据任务的紧急程度来决定处理顺序.
* 规则: 每个作业/进程各自有各自的优先级,调度时选择优先级最高的进程/作业
* 可用于进程和作业,还可以用于IO调度
* 抢占,非抢占都有,抢占式会在就绪队列改变时判断
* 优先级:
  * 就绪队列未必只有一个,可以按照不同优先级来组织,可以把优先级高的放啊在靠近队头位置
  * __静态优先级__: 创建进程时确定,一直不变
  * __动态优先级__: 创建进程时有初始值,之后会根据情况动态调整
    * 从追求公平,提升资源利用率角度考虑(比如响应比)
  * 原则:
    * 系统进程优先级 高于 用户进程
    * 前台进程优先级 高于 后台进程
    * 更偏好IO型进程(而不是CPU繁忙型进程)
* 优点: 用优先级区分紧急程度,重要程度,灵活
* 缺点: 如果源源不断高优先级,可能导致饥饿
* 会饥饿

#### 4.6 多级反馈队列调度算法

* 对其他算法折中权衡
* 只使用进程调度
* 规则:
  * 设置多级就绪队列,各级队列优先级从高到低
  * 新进程到达时先进入第一季队列,按FCFS原则排队等待被分配时间片,若时间皮用完还未结束,则进程进入下一级队列队尾
  * 只有k级队列为空时,才会为k+1级队头进程分配时间片
* __抢占式算法__,若上一级进入了一个新进程,则新进程抢占处理机
* 优点: 公平,很快响应,短进程体验好,不比比估计进程运行时间,
* __还是会饥饿__

## 五. 进程同步和互斥

### 1. 进程同步

__异步__是指,多道程序环境下,允许多个程序并发执行,但由于资源有限,进程的执行不是一贯到底的,而是走走停停(阻塞),以不可预知的速度向前推进,这就是进程的异步性.

但有时候希望进程按照我们希望的次序完成,操作系统提供__进程同步机制__实现这样的需求.

__同步__亦称__直接制约关系__,是指为完成某种任务二建立的两个或多个进程,这些进程需要在某些位置__协调工作次序__而产生制约关系.直接制约关系源于他们的相互合作

* * 

### 2. 进程互斥

我们把一个时间段内只允许一个进程使用的资源称为__临界资源__,许多物理设备都属于临界资源

对临界资源的访问只能互斥的进行

* 进入区: 上锁
* 临界区(段): 访问临界资源
* 退出区: 解锁
* 剩余区: 其他处理

如果一个进程在临界区,另一个要访问,那另一个怎么办?

* 原则:
  * **空闲让进**: 临界区空闲时,可以允许一个请求进入临界区的进程进入
  * **忙则等待**: 当已有进程进入临界区时,其他视图进入临界区进程必须等待
  * **有限等待**: 保证有限时间内能进入临界区
  * **让权等待**: 进程不能进入临界区时立即释放处理机

### 3. 具体进程互斥实现方法

#### 3.1 单标志法

* 思想: 两个进程访问完临界区后会把使用临界区的权限交给另一个进程,__每个进程进入临界区的权限只能被另一个进程赋予__.

* ```c
  int turn = 0;//turn 表示当前允许进入临界区的进程号
  ```

* ```c
  //p0进程
  while(turn != 0);//进入
  critical section;//临界区
  turn = 1;//退出,交给p1
  remainder section;//剩余
  
  //p1
  while(turn != 1);//一直循环,进入区
      critical section;
      turn = 0;//退出,交给p0
      remainder section;
  
  ```

* 可以实现互斥,但是是轮流访问的,如果其中一方不访问,就会一直卡住

* 违背了__空闲让进__

#### 4.2 双标志先检查法

* 思想: 设置一个布尔型flag[],数组中各个元素标记__各进程想进入临界区的意愿__.
* 进入临界区前先检查有没有别的进程特别想进入临界区,如果没有就把自己改成true然后访问,出来再改成false

```c
bool flag[2] = {false,false};

//p0
while(flag[1]);
flag[0] = true;
critical section;
flag[0] = false;
remainder section;

//p1
while(flag[0]);
flag[1] = true;
critical section;
flag[1] = false;
remainder section;
    
```

* 显然可能同时进入临界区,违反了__忙则等待__
* 本质来说检查和上锁不是同时进行的

#### 4.3 双标志后检查法

先上锁后检查版本双标志

* ```c
  bool flag[2] = {false,false};
  //p0
  flag[0] = true;
  while(flag[1]);
  critical section;
  flag[0] = false;
  remainder section;
  
  //p1
  flag[1] = true;
  while(flag[0]);
  critical section;
  flag[1] = false;
  remainder section;
  ```

* 还是会冲突,两个都设为true,那就都进不去,违背__空闲让进,有限等待__

#### 4.4 Peterson算法

如果双方都想进入临界区,可以孔融让梨,让出临界区

```c
bool flag[2];
int turn = 0;

//p0
flag[0] = true;
turn = 1; // 让对面
while(flag[1] && turn == 1);
critical section;
flag[0]= false;

//p1
flag[1] = true;
turn = 0;
while(flag[0] && turn == 0);
critical section;
flag[1]= false;
```

* 没有实现__让权等待__

### 4. 进程互斥的硬件实现方法

#### 4.1 中断屏蔽方法

利用"开关中断指令"实现.与愿与实现思想相同.

一个进程进入临界区就关中断,也就是不可能在临界区中有进程切换的情况.访问完开中断.

* 优点: 简单高效
* 缺点: 不适合多处理机,只适用于操作系统内核进程,不适用用户进程

#### 4.2 TS指令

就是`TestAndSet`,也叫`TSL(TestAndSetLock)`,是由硬件是极限的,执行过程不允许被中断,只能一气呵成

```c
// 背后逻辑
bool TestAndSet(bool * lock){
    bool old;
    old =  *lock;
    *lock = true;
    return old;
}
while(TestAndSet(&Lock));
临界区;
lock = false;
...
```

这只是硬件的背后逻辑

硬件上说,这就是上锁检查一气呵成,跟双标志不一样

不满足__让权等待__

#### 4.3 swap指令

也叫exchange指令和xchg指令.

用硬件实现,执行过程不允许中断

```c
swap(bool * a,bool,*b){
    bool temp;
    temp = *a;
    *a=*b;
    *b=temp;//就交换值
}
bool old = true;
while(old==true) swap(&lock,&old);
临界区;
lock=false;
```

逻辑上和TSL做的一样



### 5. 信号量机制

> 整型信号量
>
> 记录型信号量

因为前面讲的硬件软件互斥实现总有问题,不能让权等待,检查上锁一气呵成.

用户可以通过操作系统的__一对原语__(wait(S)和signal(S),S是传入的信号量,也叫__PV操作__)对信号量进行操作,实现进程互斥,进程同步,.

可以__用信号量表示系统中某种资源的数量__

##### 5.1 整型信号量

用一个整型变量作为信号量,用来表示系统中某种资源的数量.

对信号量的操作只有三种: __初始化,P操作,V操作__

```C
int S = 1;//初始化

void wait (int S){//P原语
    while(S <= 0);
    S = S - 1;
}
void signal  (int S){//V原语
    S=S+1;
}

wait(S);
使用资源;
signal(S);
```

会忙等,不满足让权等待.

#### 5.2 记录型信号量

用一个记录型信号量

```C
typedef struct{
    int value; //剩余资源数
	struct process *L;//等待队列
}semaphore;
        


void wait(semaphor S){
	S.value--;
    if(S.value < 0){
        bolck(S.L);//把当前进程主动阻塞的block原语,挂到信号量S的等待队列
    }
}
void signal(semaphor S){
	s.value++;
    if(S.value <= 0){
        wakeup(S.L);//如果有人在排队,就唤醒
    }
}
```



这对原语可以实现资源的申请和释放

#### 5.3 信号量实现进程互斥

> 1. 分析并发进程的关键活动,划定临界区.
> 2. 设置__互斥信号量__,mutex,初值为1
> 3. 对不同临界资源需要不同信号量

```C

semaphore mutex = 1;//简写

P1(){
    P(mutex);
    临界区;
    V(mutex)
}
```

#### 5.4 用信号量实现进程同步

有前后顺序即为同步.

> 1. 设置同步信号量S,初始为0
>
> 2.  在__前操作__之后执行V(S),__后操作__之前执行P(S)

```C
//代码4在代码2之后

semaohore S = 0;
P1(){
    代码1;
    代码2;
    V(S)
    代码3;
}
P2(){
    P(S)
   代码4;
    代码5;
}
```

#### 5.5 信号量实现进程前驱关系

如果安排要求像aoe网一样复杂,那我们:

1. 为每一对前驱关系设置同步变量
2. 在前操作后V
3. 后操作前P

### 附. 生产者-消费者问题

* 是一个经典问题,具体内容如下:

<u>生产者</u>(Productor)将产品交给<u>店员</u>(cleck),而<u>消费者</u>(Customer)从店员处取走商品.店员一次只能持有固定数量的商品(比如: 20),
如果生产者试图生产更多的商品,店员会叫生产者停一下.如果店中有空位了再通知生产者继续生产.
若店中没有商品了,店员会告诉消费者等一下.有产品了再来通知消费者取走

* 解答的代码在javaidea的`day01的java2的ProductTest`中

#### 附.1 用PV实现

信号量机制可以实现互斥,同步,对一类系统资源的申请和释放

* 缓冲区满时有同步关系,生产者要等待消费者取走产品.
* 缓冲区空时有同步关系,消费者要等待生产者放入物品
* 缓冲区是临界资源,互斥访问

分析:

生产者每次要消耗(P)一个空闲缓冲区,并(生产)V一个产品.

消费者每次要消耗(P)一个产品,并释放(V)一个空闲缓冲区

需要互斥.

代码:

```C
//初始化信号量
semaphore mutex = 1; //互斥信号量,实现对缓冲区的互斥访问
semaphore empty = n; //同步信号量,表示空闲缓冲区的数量
semaphore full = 0;  //同步信号量,表示产品数量(非空缓冲区数量)
//*********

producer(){
    while(1){
        生产一个产品;
        P(empty);
        P(mutex);
        把产品放入缓冲区;
       	V(mutex); 
        V(full);
        
    }
}
    
consumer(){
	P(full);
    P(mutex);
    从缓冲区取产品;
    V(mutex);
    V(empty);
    使用产品
}
    
```

如果互斥的p在同步的p前会出现死锁;而V操作可以交换顺序

#### 附.2 多生产者多消费者问题

多不是多个,而是多类.一个消费者只需要一类数据,一个生产者只生产一类数据

* 对盘子要互斥的进行
* 同步关系:
  * 父亲放苹果->女儿拿苹果
  * 母亲放句子->儿子拿橘子
  * 盘子为空->放水果

![image-20200614194600076](C:\Users\carrzhou\AppData\Roaming\Typora\typora-user-images\image-20200614194600076.png)

![image-20200614194756477](C:\Users\carrzhou\AppData\Roaming\Typora\typora-user-images\image-20200614194756477.png)

### 附. 吸烟者问题

假设系统有三个抽烟者进程和一个供应者进程.每个抽烟者不停地卷烟并抽掉它,但是要卷起并抽掉一支烟,抽烟者需要有三种材料: 烟草,纸和胶水. 三个抽烟者中,第一个拥有烟草,第二个拥有纸,第三个拥有胶水,供应者进程无限的提供三种材料.供应者每次把两种材料放桌子上,拥有剩下那种材料的抽烟者卷一根烟并抽掉它,并给供应者一个信号高速完成了.供应者就会放另外两种材料在桌子上,如此循环.

* 桌子可以看做容量为1的缓冲区,要互斥访问(每次桌子上能放一个材料组合)
  * 这是互斥关系
* 桌上有 纸+胶水(组合一) 后 第一个抽烟者取走东西
* 桌上有组合二 -> 第二个抽烟者取走东西
* 桌山有组合三: 第三个抽烟者取走东西
* 发出完成信号=>供应者拿出下一个组合

```C
semaphore offer1 = 0;//组合1
semaphore offer2 = 0;//组合2
semaphore offer3 = 0;//组合3
semaphore finish = 0;//完成信号
int i = 0;//用于轮流

provider(){
    while(1){
        
        if(i==0){
       		组合一放桌上 ;
       		V(offer1);
            
        }else if(i == 1){
            组合二放桌上;
            V(offer2);
        }else if(i == 2){
            组合三放桌上;
            V(offer3);
        }
        i = (i + 1) % 3;
        P(finish);
    }
}

smoker i(){
    while(1){
        P(offer i);
       拿走组合; 
        V(finish);
    }
}
```

### 附. 读者-写者问题

有读者和写者两组并发进程,共享一个文件.当两个或两个以上的读进程同时访问数据不会产生副作用.但若某个写进程和其他进程同时访问共享数据时则可能产生数据不一致的错误;因此要求:

1. 允许多个读者同时对文件执行操作
2. 只允许一个写者往文件中写信息.
3. 任意写者在完成写操作之前不允许其他读者或写者操作
4. 写者执行写操作前,应让已有的读者和写者全部退出

* 分析
  1. 写进程-写进程 互斥; 写进程-读进程 互斥;

设置互斥信号量rw,在写进程执行前后进行PV操作.使用count来记录当前有几个读进程在访问文件,然后用PV对读进程互斥

```C
semaphore w = 1;//不加是读优先,加了是读写公平法

semaphore rw = 1;
int count = 0;
semaphore mutex = 1;

write(){
    while(1){
        P(w);
        P(rw);
        写;
        V(rw);
        V(w);
    }
}

reader(){
    while(1){
        P(w);//防止写进程被读进程饿死
        P(mutex);//保证对count操作的原子性
        if(count == 0) P(rw);//先进来的关门
        count++;
        V(mutex);
        V(w);
        读;
        P(mutex);
        count--;
        if(count==0) V(rw);//最后走的开门
        
        V(mutex);
    }
}
```

#### 附. 哲学家进餐问题

一个圆桌上坐五名哲学家.每两个哲学家之间的桌上摆一根筷子/桌子中间是一碗米饭.哲学家倾注毕生精力思考和用餐.思考时不影响他人,饥饿时会(先后)拿起左右两只筷子进餐.如果筷子在他人受伤,需要等待.哲学家同时拿两只筷子才能用餐,用餐完毕后继续思考.

* 分析:
  * 只有对相同筷子的访问是互斥关系.
  * 但是需要持有两份临界资源才能开始吃饭,如何__避免死锁__是这个问题的精髓

* 信号量设置: 定义互斥信号量数组 chopstick[5] = {1,1,1,1,1}; 并对哲学家0-4编号.哲学家i左边筷子记为i,右边筷子记为(i + 1 )% 5

* 简单逻辑,会发生死锁

  ```C
  semaphore chopstick[5] = {1,1,1,1,1};
  Pi(){
  	while(1){
          P(chopstick[i]);
          P(chopstick[(i + 1)%5]);
          吃饭;
         V(chopstick[i]);
         V(chopstick[(i + 1)%5]);
          
          
          思考;
      }
  }
  ```

* __如何避免死锁?__

  * 最多允许4个哲学家同时进餐
  * 奇数号先拿左边,偶数号先拿右边
  * 仅当哲学家两边都能有筷子时拿起筷子(用互斥信号量实现)
    * 实际并没有实现这样的理念,而是保证对筷子的访问都是互斥进行