# 操作系统

> [TOC]

## 一. 绪论

### 1. 操作系统的地位

本质是__系统软件__

* <u>系统资源的管理者</u>
  * 处理机(CPU)管理
  * 存储器(内存)管理
  * 文件管理
  * 设备管理
  * 以安全高效为目标
* <u>用户与计算机硬件之间的接口</u>
  * 命令接口: 允许用户直接使用
    * 联机(交互式)命令接口
    * 脱机(批处理)命令接口
  * 程序接口: 允许用户通过程序间接使用
    * 由一组__系统调用/程序接口/广义指令__组成(同一个意思)
  * GUI
  * 以**方便用户**使用为目标
* <u>最接近硬件的层次</u>
  * 没有软件支持的计算机称为__裸机__,覆盖了软件的机器称为__扩充机器/虚拟机__

### 2. 操作系统四大特征

> ==**并发**==
>
> ==**共享**==
>
> ==**虚拟**==
>
> ==**异步**==

#### 2.1 并发

* 定义:

  **并发**指两个或多个时间在$\color {blue}同一时间间隔发生$. <u>宏观上同时发生,在微观上交替发生</u>

  * 易混淆: __并行__指连个或多个事件在$\color {blue}同一时刻同时发生$

  **操作系统的并发性** 指计算机系统中同时存在着多个运行着的程序

  * 单核CPU同一时刻只能执行一个程序,因此操作系统会负责协调多个程序交替执行
  * 操作系统和"多道程序技术"是伴随出现的,所以操作系统和程序并发一起诞生

#### 2.2 共享

* 定义:

  __共享__即资源共享,指系统中的资源可供内存中多个并发执行的进程共同使用

* 分类:两种资源共享的方式
  * 互斥共享方式(一个时间段只允许一个进程访问该资源)
  * 同时共享方式(一个时间段内进程可以"同时"访问该资源)

#### 并发和共享的关系

如果失去并发性,共享性也失去了存在的异议

如果没有共享性,就无法并发

**互为存在条件**

#### 2.3 虚拟

__虚拟__是指把一个物理上的实体变成若干个逻辑上的对应物.前者是实际存在的,后者是用户感受到的.

* ""空分复用技术"(空间 虚拟存储器)
* "时分复用技术"(时间 虚拟处理器)

没有并发性,谈不上虚拟性

#### 2.4 异步

__异步__是指,多道程序环境下,允许多个程序并发执行,但由于资源有限,进程的执行不是一贯到底的,而是走走停停(阻塞),以不可预知的速度向前推进,这就是进程的异步性.

没有并发性也没有异步性

--------

### 3. OS的发展和分类

1. ==手工发展阶段==
   * 纸带打孔
   * CPU快,IO慢,人类处理慢
   * 缺点总结: 用户独占主机,人机速度矛盾导致资源利用率低
2. ==批处理阶段--单道批处理系统==
   * 引入__脱机输入/输出技术__(读到磁带里,输出到磁带),并由__监督程序(OS雏形)__负责控制作业的输入输出
   * 优点: 缓解了一定程度的人机速度矛盾,资源利用率有所提升
   * 缺点: 内存中**仅有一道程序运行,只有该程序运行结束才能调入**下一道,CPU有大量时间是在**等待IO完成**,资源利用率也不高
3. ==批处理阶段--多道批处理处理技术==
   * 每次往内存中输入多道程序,引入了__中断技术__
   * __操作系统正式诞生__,负责管理这些程序运行,各个程序并发执行
   * 优点: 多道程序**并发执行**,**共享**计算机资源,资源利用率大大提升.CPU和其他资源保持忙碌状态,系统吞吐量增大
   * 缺点: 用户响应时间长,没有人机交互功能
   * ![image-20200525144428484](C:\Users\carrzhou\AppData\Roaming\Typora\typora-user-images\image-20200525144428484.png)
   * ![image-20200525144452242](C:\Users\carrzhou\AppData\Roaming\Typora\typora-user-images\image-20200525144452242.png)

4. ==分时操作系统==
   * 计算机以__时间片__为单位轮流为各个用户/作业服务,各个用户可以通过终端与计算机交互
   * 优点: 用户请求可以被即时响应,解决了人机交互问题,允许多个用户同时使用一台计算机,并且用户对计算机的操作相互独立,感受不到别人存在
   * 缺点: **不能优先处理一些紧急任务,**每个用户都是公平的
5. ==实时操作系统==
   * 在实时操作系统的控制下,计算机系统接受到外部信号后及时进行处理,并且要在**严格时限内处理完事件.**(硬实时要求必须,软实时接收偶尔违反)
   * 优点: 能够优先相应一些紧急任务,某些紧急任务不需要时间片排队
   * 特点: **及时性,可靠性**

6. 其他

   网络操作系统

   分布式操作系统

   个人计算机操作系统

### 4. OS运行机制和体系结构

#### 4.1 运行机制

* __两种指令__:
  * <u>特权指令</u>
  * <u>非特权指令</u>
* __两种处理器状态__:
  * <u>用户态**(目态)**</u> : 只能执行非特权指令
  * <u>核心态**(管态)**</u> :都能执行
  * 两种状态用__程序状态字寄存器(PSW)__中的某个标志位标识(0用户态,1管态)
* __两种程序__:
  * <u>内核程序:</u> 是系统的管理者,运行在核心态
  * <u>应用程序</u> : 运行在用户态

#### 4.2 OS内核(kernel)

内核掌管`时钟管理`,`中断处理`,`原语(最接近硬件,有原子性)`,`进程管理,存储器管理,设备管理等功能`

__内核__是计算机配置上的__底层软件__,是操作系统最基本,最核心的部分.

实现操作系统功能的的程序就是__内核程序__

![image-20200525150333985](C:\Users\carrzhou\AppData\Roaming\Typora\typora-user-images\image-20200525150333985.png)

#### 4.3 体系结构

OS的体系结构分为`大内核`和`微内核`

* 如果操作系统内核只包含最基本的功能,则为__微内核__
  * 优点: 内核功能少,结构清晰,易于维护
  * 缺点: 需要频繁地在核心态和用户态之间切换,性能低
* 将操作系统主要模块都作为系统内核,则为__大内核__
  * 优点: 高性能
  * 缺点: 内核代码庞大.结构混乱,难以维护

### 5. 中断和异常

早期个程序只能串行执行,效率低下. 

人们发明了操作系统,引入中断机制,实现了多道程序并发执行.

* __本质__: 发生中断意味着**需要操作系统介入,**开展管理工作
  * CPU在收到中断信号会转换为**核心态**
  * ,**由操作系统内核对中断处理**
  * 对不同的中断信号,会进行不同处理
* 用户态与核心态
  * <u>用户态到核心态的切换</u>是通过中断来实现的,<u>并且中断是唯一的途径</u>	
  * 而<u>核心态到用户态</u>通过特权指令,改变程序状态字

#### 5.1 分类

* ==内中断(异常,例外,陷入)==
  * 来源: CPU**内部,**与**当前执行的指令有关**
    * ==自愿中断==--仿管(trap,陷入)指令中断
    * ==强迫中断==(硬件故障(缺页)/软件中断(除以0))
* ==外中断(狭义中断)==
  * 来源: CPU__外部__,当前执行的指令__无关__
    * ==外设请求==(例如IO操作完成)
    * ==人工干预==

* __另一种内中断分类__
  * 陷阱,陷入(trap): 有意而为之的,如系统调用
  * 故障(fault) :由错误条件引起的,可能被故障处理程序修复
  * 终止(abort) :不可修复的致命错误,不再将控制权返回

### 6. 系统调用

前面我盟说过,程序接口由__一组系统调用__组成

应用程序通过**系统调用**请求操作系统的服务.凡是与**资源有关**的操作,都必须通过系统调用的方式向操作系统提出服务请求,由操作系统代为完成,这样可以**保证系统的稳定性和安全性**,防止用户非法操作

需要特权指令,运行在__核心态__

可以理解为操作系统提供的接口.

* 按功能分类:
  * 设备管理 : 完成设备的 请求 释放 启动等
  * 文件管理 : 完成文件的 读写创建删除 等
  * 进程控制 : 完成进程的 创建撤销阻塞唤醒
  * 进程通信 : 完成进程的 消息传递 信号传递
  * 内存管理 : 完成内存的 分配/回收功能

* 调用:
  * 前期处理相关指令
  * trap指令/陷入指令(内中断)
  * 后续处理指令,操作系统处理 系统调用 相关代码(核心态)
  * 注意: __陷入指令是唯一只能在用户态而不能在核心态执行的指令__

## 二. 进程

### 1. 进程

* 定义:
  * __程序__: 一个指令序列
  * 为了方便管理.完成个程序并发执行,引入了__进程,进程实体__的概念
    * <u>PCB(进程控制块),程序段,数据段构</u>成了__进程实体/进程映像__,简称进程
    * ==PCB是进程存在的唯一标志==
  * 进程是进程实体(静态)的__运行过程__,是__动态的__,是资源分配和调度的一个独立单位

* __组成__

  * 程序段: 存储程序代码
  * 数据段: 产生的数据
  * PCB: 操作系统通过PCB管理进程,存储操作系统对其管理的各种信息
    * **进程描述信息:** 
      * 进程标识符PID
      * 用户标识符UID
    * **进程控制和管理信息**
      * 进程当前状态
      * 进程优先级
    * **资源分配清单**
      * 程序段指针
      * 数据段指针
      * 键盘
      * 鼠标
    * **处理机相关信息 --寄存器的值**

* __组织__:

  PCB成百上千,组织讨论的是多个进程之间的组织方式问题.

  * **链接方式**
    * 按照进程状态把PCB分为多个队列,操作系统持有指向各个队列的指针
      * 
  * **索引方式**
    * 根据进程状态不同,建立几张索引表,操作系统拥有指向索引表的指针

整体来说,就是有`执行指针,就绪队列指针,阻塞队列指针`

* __特征__
  * **动态性**: 最基本特征,动态的产生和消亡
  * **并发性**: 各进程并发自行
  * **独立性**: 进程是__能独立运行,独立获取资源,调度的基本单位__
  * **异步性** : 各自独立,不可预知,需要进程同步机制
  * **结构性**: PCB+程序段+数据段

### 2. 进程状态转换

#### 2.1 三种基本状态

* __运行态(Running)__: 占有CPU,单核下时刻最多有一个运行态进程
* __就绪态(Ready)__: 拥有除了处理机外的所有资源,就等CPU
* __阻塞态(waiting/blocked)__:

#### 2.2 另外两种

* __创建态(New)__: 分配资源,初始化PCB
* __终止态(Terminated)__: 反上


#### 2.3 转换

![image-20200527150307525](C:\Users\carrzhou\AppData\Roaming\Typora\typora-user-images\image-20200527150307525.png)

### 3. 进程控制

进程控制的主要功能是对系统中所有进程实施有效的管理,它具有创建新进程,撤销已有进程,实现进程状态转换等功能.

#### 3.1 如何实现进程控制?

使用==原语==实现进程控制,其__特点__是<u>原子性:执行期间不允许中断</u>,也叫原子操作

原语采用__关中断指令__和__开中断指令__实现,是核心态的特权指令

关中断下收到外部中断信号不会处理,开中断会处理

所做的事无非是`更新PCB信息(状态标志,运行环境)`,`将PCB放入合适队列`,`分配回收资源`

* __创建进程__:
  * 由`创建原语`: 
  * 需要初始化PCB,分配系统资源
* 创建态到就绪态:
  * 修改PCB内容和相应队列
* 就绪态到运行态:
  * 恢复进程运行环境,修改PCB内容和相应队列
* 运行态到阻塞态:
  * 阻塞原语
  * 保存进程运行环境,修改PCB内容和相应队列
* 阻塞态到就绪态:
  * 唤醒原语(和阻塞原语曾对出现)
  * 修改PCB内容和相应队列,分配资源
* 运行态到终止态:
  * 由`撤销原语`:找到PCB,剥夺CPU,中止子进程,收资源,删PCB
  * 回收资源,撤销PCB

还有进程切换原语

#### 3.2 引起进程创建/结束的事件

* 用户登录
* 作业调度
* 提供服务
* 应用请求



* 正常结束
* 异常结束
* 外界干预

### 4. 进程通信

进程之间的信息交换叫进程通信.

每个进程拥有内存地址空间,相对独立,进程之间不能互相直接访问.

#### 4.1 三大方式

* **共享存储**:
  * 基于数据结构的共享
  * 基于存储区的共享
* **消息传递**
  * 直接通信方式
  * 间接通信方式
* **管道通信**

#### 4.2 共享存储

进程之间分配一个共享空间,但是每个时刻只有一个进程能访问(称为__互斥性__),操作系统会提供同步互斥工具

* 基于数据结构的共享:

  * 只能村固定的数据结构

  * 速度慢,限制多,是低级通信方式
* 基于存储区共享
  * 在内存划一块共享存储区
  * 是高级方式

#### 4.3 管道通信

__管道__是指用于连接读写进程的共享文件,又名pipe.就是内存中开辟的固定大小缓冲区

* 管道只能实现__单双工通信__,某个时间段只能单向传输,想双向同时必须两个管道.
* 各进程__互斥__的访问管道
* 数据以__字符流__写入管道,写满时写进程的write()阻塞,这时才能开始取数据.取完(管道为空)时read()阻塞,才能写
* 读出管道的数据就被抛弃了,所以读进程就只有一个

#### 4.4 消息传递

进程间数据以__格式化消息__为单位,通过__发送消息/接收消息原语__进行数据交换

* 格式化消息
  * 消息头: 包括进程ID,接收进程ID,消息类型,长度等信息.
  * 消息体
* 直接通信方式:
  * 消息直接挂在接收进程消息的缓冲队列上
* 间接通信方式:(信箱通信方式)
  * 先发送到中间实体(信箱)

## 三. 线程

一个进程多个功能,传统进程内部串行,所以需要多线程<u>增加并发度</u>

__线程__被引入后,成为了<u>程序执行流的最小单位</u>,<u>CPU最小单元</u>

而进程成为了<u>除了CPU以外的系统资源的分配单元</u>

### 1. 变化

* 资源分配,调度
* 并发性
* 系统开销
  * 切换线程,开销小
  * 进程切换开销极大

### 2. 属性

* 线程是处理机调度的基本单位
* 多CPU计算机中,各个线程可占用不同CPU
* 每个线程有一个ID,线程控制块(TCB)
* 线程也有就绪,阻塞,运行三个状态
* 几乎不拥有系统资源
* 同一进程不同线程共享进程资源
* 同一进程的线程通信无需系统干预
* 同一进程中的线程切换不会引起进程切换,不同的就会
* 切换同一进程的线程开销小

### 3. 实现方式

* **用户级线程(ULT)**
  * 通过线程库来实现. 所有**线程管理工作由应用程序负责**(包括线程切换)
  * 在**用户态**下即可完成,对操作系统看不到线程存在
* __内核级线程(KLT)__
  * **由操作系统内核完成线程管理**,核心态
  * 从操作系统角度能看到的线程

如果两者同时支持,可以吧n个用户级线程映射到m个内核级线程上.

因为操作系统只能看到内核级线程,所以__内核级线程才是处理机分配的单位__.

比如用户3个线程映射到内核2个线程,那最多有2个核执行线程,只有2个线程并行

* 多线程问题:
  * 因为用户级和内核级的映射问题,产生了多线程模型问题
  * __多对一__: 多个用户级映射到一个内核级时
    * 线程切换只需要在用户态
    * 并发性不高,阻塞时进程被阻塞
  * __一对一__:纯粹的内核级线程
    * 并发能力强,多核并行
    * 管理的成本高
  * __多对多__:n个映射到m
    * 并发还行,成本还行

## 四. 处理机调度

当有一堆任务要处理,但由于资源有限,不能同时处理,这就需要确定**某种规则**来**决定**处理这些任务的**顺序**,这就是调度的研究问题

简单地说,从就绪队列中按照**一定算法选择一个进程**并将处理机分配给它运行

### 1. 三个层次

* __高级调度(作业调度)__: 按一定原则从外存处于后备队列的作业中挑选一个作业,分配内存等资源并建立PCB(进程),使他们获得竞争 处理机的权利
  * 是__外存和内存__之间的调度,每个作业只调入一次,调出一次,作业调入设置会建立相应的PCB,调出是撤销PCB.
  * 高级调度指的是调入问题.
  * 无-->创建态-->就绪态
* __中级调度(内存调度)__:引用虚拟存储技术之后,可将暂时不能运行的进程调至外存等待,当他具备了运行条件且内存有空闲时再重新调回内存
  * 目的是**提高内存利用率**和**系统吞吐量**
  * 暂停的进程状态为__挂起__,而PCB却__常驻内存__,放在__挂起队列中__
  * 中级调度处理的是哪个处于挂起状态的进程进入内存
  * 频率比高级调度高
* 补充:七状态模型
  * 就绪挂起: 就绪态需腾出内存挂起
  * 阻塞挂起: 阻塞态腾出内存,有事时可以变成就绪挂起
  * 运行态和创建态都能直接到就绪挂起
* __低级调度(进程调度)__: 用算法给进程分配处理机
  * 操作系统中最基本的调度
  * 频率很高

### 2. 进程调度

#### 2.1 进程调度时机

* 当前运行的进程**主动放弃**处理机(有的系统只允许这个)
  * 正常终止,异常终止,请求阻塞
* 当前运行的进程**被动放弃**处理机
  * 时间片用完
  * 有更紧急的事处理(如IO中断)
  * 有更高优先级的进程进入优先队列

* 不能进行进程调度的情况:
  * 处理中断的过程中
  * <u>操作系统内核程序临界区</u>中
    * __临界资源__: 一个时间段内只允许一个进程使用的资源,各进程需要互斥的访问临界资源
    * __临界区__:访问临界资源的那一段代码
    * __内核程序临界区__: 访问某种内核程序,比如进程就绪队列
    * 如果内核临界区的临界资源不尽快释放可能影响到其他内核管理工作,所以不能进程调度
  * 原语操作不可中断

#### 2.2 进程调度方式

* __非剥夺(非抢占)方式__: 只允许进程主动放弃处理机,直到中止或阻塞
* __剥夺(抢占)调度方式__: 当一个进程在处理机执行时,如果有一个更重要的进程使用,则立即暂停当前进程,分配给紧急进程

#### 2.3 进程切换与过程

* __狭义的进程调度__: 指从就绪队列中选中一个要运行的进程
  * 可以是刚被暂停的,也可以是另一个进程,后者需要__进程切换__
* __广义的继承调度__: 包含了狭义进程+进程切换

* 进程切换的过程主要完成了:
  * 对原来运行的进程的各种数据的保存
  * 对新进程数据的恢复

频繁的个切换会使系统效率变低

### 3. 调度算法的评价指标

* __CPU利用率__: 指CPU忙碌的时间占总时间的比例
  $$
  
  利用率=\frac {忙碌时间}{总时间}
  $$
  

* __系统吞吐量__: 单位时间内完成作业的数量
  $$
  吞吐量(道/秒)=\frac {总共完成多少道作业}{总共多少时间}
  $$

* __周转时间__: 指作业被提交给系统开始.到作业完成的时间间隔

  * 分为:高级调度时间,低级调度时间,CPU执行时间,等待IO时间

  * __平均周转时间__: 各作业周转之和/作业数

  * __带权作业周转时间__:(必然大于1)(越接近1越好)
    $$
    带权作业周转时间=\frac{作业周转时间}{作业实际运行时间}=\frac{作业完成时间-作业提交时间}{作业实际运行时间}
    $$

  * __平均带权周转时间__: 上面除以作业数

* __等待时间__:指进程.作业处理等待处理机状态时间之和,越小越好

  * 对于__进程__来说,等待时间是进程建立后等待被服务的时间之和(IO不计入等待时间)
  * 对于__作业:__ 不仅考虑建立进程后的等待时间,也要加上作业在外存后备队列的准备时间
  * 调度算法只会影响等待时间,也有平均等待时间

* __响应时间__:用户提出请求到首次产生相应的时间