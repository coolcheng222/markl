# C++碎片整理

## 一. const

const即不变

1. const修饰的局部变量不进入全局区

2. const修饰指针时:

   ```C++
   const int * a;// const在*前,内容不变,包括结构体的字段之类的任何内容
   int * const b;// const在*后,指针不变
   //以上两点对形参也有效,但后者其实没什么用
   
   const int * a,b; //b:const int,共享const
   int * const a,b; //b: int
   const int * a,*const b;//猜猜看
   ```

<u>实际上 const int * 就是指向const int 的指针,两者应该属于对应关系; const int 的地址无法赋值给int *</u>

## 二. 引用

### 1. 引用

引用的特点: 

1. 初始化时将变量传入,则称为该变量的引用

2. 引用的指向不会改变,后续赋值操作的都是被引用变量

3. 无法引用const常量

   ```c++
   int &b = a;//b是指向a的引用
   b = c;//将c赋值给a
   ```

引用的本质:

1. 初始化时称为指针常量

2. 使用时采用取值符号

   ```c++
   int &b = a;//int * const b = &a;所以必须引用一块合法的内存空间
   b = c;//*b = c;
   ```

### 2. 常量引用

常量引用主要应用于形参,防止对值的修改

1. 对变量引用的情况:

   ```c++
   int & ref = 10;//不可行,引用必须指向一块合法的内存空间
   const int & ref = 10;//可行,编译器会将10赋值给临时变量,然后ref引用这个变量;ref只读,不可修改
   ```

   

## 三. 函数

### 1. 默认参数

1. <u>函数如果声明时写了默认参数,实现就不需要(不能)写默认参数</u>

### 2. 占位参数

作用就是占一个参数位置(?),在运算符重载时展开

```c++
//语法
int abc(int a,int,int b) { // 只声明类型不声明形参,成为占位参数
	return a + b;
}
int bcd(int = 10);//占位参数可以有默认,语法如此句

int main() {
	cout << abc(10,10,10) << endl; //调用时需要传(没有默认值的情况下)
	system("pause");
	return 0;
}
```

